import sys
import strax
import straxen
import numba
import numpy as np
from immutabledict import immutabledict
from collections import defaultdict


export, __all__ = strax.exporter()

__all__ += ['T_NO_VETO_FOUND']
# Runs are usually 1 hour long, if veto is that far we don't really care
T_NO_VETO_FOUND = int(3.6e+12) 

# More info about the acquisition monitor can be found here:
# https://xe1t-wiki.lngs.infn.it/doku.php?id=xenon:xenon1t:alexelykov:acquisition_monitor

@export
@strax.takes_config(strax.Option('hit_min_amplitude_aqmon', default=50, track=True,
                                 help='Minimum hit threshold in ADC*counts above baseline'),
                    strax.Option('baseline_samples_aqmon', default=10, track=True,
                                 help='Number of samples to use at the start of the pulse to determine the baseline'))
class AqmonHits(strax.Plugin):
    """ Find hits in acquisition monitor data. These hits could be 
        then used by other plugins for deadtime calculations, 
        GPS SYNC analysis, etc.
    """
    __version__ = '0.0.4'

    depends_on = ('raw_records_aqmon')
    provides = ('aqmon_hits')
    data_kind = ('aqmon_hits')

    dtype = strax.hit_dtype

    save_when = strax.SaveWhen.TARGET

    def compute(self, raw_records_aqmon):
        rec = strax.raw_to_records(raw_records_aqmon)
        strax.zero_out_of_bounds(rec)
        strax.baseline(rec, baseline_samples=self.config['baseline_samples_aqmon'], flip=True)
        aqmon_hits = strax.find_hits(rec, min_amplitude=self.config['hit_min_amplitude_aqmon'])

        return aqmon_hits

#### Veto hardware ####:
# V1495 busy veto module:
# Generates a 25 ns NIM pulse whenever a veto begins and a 25 ns NIM signal when it ends.
# A new start signal can occur only after the previous busy instance ended.
# 1ms (1e6 ns) - minimum busy veto length, or until the board clears its memory

# DDC10 High Energy Veto:
# 10ms (1e7 ns) - fixed HE veto length in XENON1T DDC10,
# in XENONnT it will be calibrated based on the length of large S2 SE tails
# The start/stop signals for the HEV are generated by the V1495 board

@export
@strax.takes_config(
    strax.Option('max_veto_window', default=int(5e8), track = True, type = int,
                 help='Maximum separation between veto stop and start pulses [ns]'),
    strax.Option('channel_map', type = immutabledict, track=False, 
                 help='immutabledict mapping subdetector to (min, max)'
                      'channel number'))
class VetoIntervals(strax.OverlapWindowPlugin):
    """ Find pairs of veto start and veto stop signals and the veto duration between them
    busy_*  <= V1495 busy veto for tpc channels
    he_*    <= V1495 busy veto for high energy tpc channels
    hev_*   <= DDC10 hardware high energy veto
    """

    __version__ = '0.1.2'
    depends_on = ('aqmon_hits')
    provides = ('veto_intervals')
    data_kind = ('veto_intervals')

    def infer_dtype(self):
        dtype = [(('veto start time since unix epoch [ns]', 'time'), np.int64),
                 (('veto end time since unix epoch [ns]', 'endtime'), np.int64),
                 (('veto interval [ns]', 'veto_interval'), np.int64),
                 (('veto signal type', 'veto_type'), np.str('U9'))]
        return dtype

    def setup(self):
        aq_ch_start = straxen.n_hard_aqmon_start
        aqmon_channel_names = ('sum_wf', 'm_veto_sync',
                               'hev_stop', 'hev_start', 'he_stop', 'he_start', 'busy_stop', 'busy_start')
        channel_numbers = np.arange(aq_ch_start, aq_ch_start + len(aqmon_channel_names))

        # Keeping ch_range as class attribute for now, maybe will need it for other features
        self.channel_range = self.config['channel_map']['aqmon']
        self.channel_map = dict(zip(aqmon_channel_names, channel_numbers))
        self.veto_names = ['busy_', 'he_', 'hev_']

    def get_window_size(self):
        # Give a very wide window
        return (self.config['max_veto_window'] * 100)

    def compute(self, aqmon_hits):
        hits = aqmon_hits

        res = defaultdict(list)
        
        for n, name in enumerate(self.veto_names):
            veto_hits_start = channel_select_(hits, self.channel_map[name + 'start'])
            veto_hits_stop = channel_select_(hits, self.channel_map[name + 'stop'])
            
            # Here we rely on the fact that for each start, there is a single stop that 
            # follows it in time. If this is not true, our hardware does not work. 
            if len(veto_hits_start):
                for t, time in enumerate(veto_hits_start['time']): 
                    # Find the time of stop_j that is closest to time of start_i
                    inx = np.searchsorted(veto_hits_stop['time'], time, side = 'right') 
                    
                    if inx == len(veto_hits_stop['time']):
                        continue
                    else:
                        res['veto_interval'].append(veto_hits_stop['time'][inx] - time)
                        res["time"].append(time)
                        res["endtime"].append(veto_hits_stop['time'][inx])
                        res["veto_type"].append(name + 'veto')
        
        result = strax.dict_to_rec(res, self.dtype)
        return result

@numba.njit
def channel_select_(rr, ch):
    """Return data from start/stop veto channel in the acquisition monitor (AM)"""
    return rr[rr['channel'] == ch] 




@export
@strax.takes_config(
    strax.Option('veto_proximity_window', default=int(5e8), type=int, track=True,
                 help='Maximum separation between veto stop and start pulses [ns]'))

class VetoProximity(strax.OverlapWindowPlugin):
    """ 
    Find the closest next/previous veto start and end to each event center.
    
    previous_x: Time in ns between the time center of an event and the previous x
    next_x: Time in ns between the time center of an event and the next x
    This also considers any x inside the event. x could be either:
        - busy_x: busy on/off signal
        - he_x:   high energy channels busy on/off signal
        - hev_x:  high energy veto on/off signal
    """
        
    __version__ = '0.0.2'
    depends_on = ('veto_intervals','events') 
    provides  = ('veto_proximity')
    data_kind = ('veto_proximity')
    
    veto_names = ['busy', 'he', 'hev']
    
    save_when = strax.SaveWhen.NEVER
    
    def infer_dtype(self):
        dtype = []
        for n in self.veto_names:
            dtype.append((('Time to previous %s veto start [ns]' %n, 'previous_%s_on' %n), np.int64))
            dtype.append((('Time to previous %s veto end [ns]' %n, 'previous_%s_off' %n), np.int64))
            dtype.append((('Time to next %s veto start [ns]' %n, 'next_%s_on' %n), np.int64))
            dtype.append((('Time to next %s veto end [ns]' %n, 'next_%s_off' %n), np.int64))
        
        dtype += strax.time_fields

        return dtype
    
    def setup(self):
        self.states = ['on', 'off']
    
    def get_window_size(self):
        return (self.config['veto_proximity_window'] * 100)
        
    def compute(self, events, veto_intervals):
        res = defaultdict(list)
        
        t_event_centers = (events['time'] + events['endtime'])//2

        for n, name in enumerate(self.veto_names):
            veto_selection = veto_intervals[veto_intervals['veto_type'] == ('%s_veto' %name)]
            
            # For each state find the next and previous veto
            for state in self.states:
                prev = 'previous_%s_%s' %(name, state)
                nxt = 'next_%s_%s' %(name, state)
                
                if state == 'on':
                    veto_start_time_selection = veto_selection['time']
                else:
                    veto_start_time_selection = veto_selection['endtime']
                    
                for t, time in enumerate(t_event_centers):
                    inx = np.searchsorted(veto_start_time_selection, time, side = 'right')
                    
                    # Time to previous veto on/off
                    # Just using maxsize as a huge value that will not fit in any potential VetoCut range
                    if inx == 0:
                        res[prev].append(T_NO_VETO_FOUND)
                    else:
                        res[prev].append(time - veto_start_time_selection[inx - 1]) 
            
                    # Time to next veto on/off
                    if inx == len(veto_selection):
                        res[nxt].append(T_NO_VETO_FOUND)
                    else:
                        res[nxt].append(veto_start_time_selection[inx] - time)

        # Add the events time and endtime to the final result
        res['time'].extend(events['time'])
        res['endtime'].extend(events['endtime'])

        result = strax.dict_to_rec(res, self.dtype)
        
        return result
